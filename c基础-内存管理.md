[toc]

# 作用域

C语言变量的作用域分为：

-   l 代码块作用域(代码块是{}之间的一段代码)

-   l 函数作用域

-   l 文件作用域

## 局部变量

局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量，它有如下特点：

-   在一个函数内定义，只在函数范围内有效

-   在复合语句中定义，只在复合语句中有效

-   随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束

-   ==如果没有赋初值，内容为随机==

```c
#include <stdio.h>

void test()
{
	//auto写不写是一样的
	//auto只能出现在{}内部
	auto int b = 10; 
}

int main(void)
{
	//b = 100; //err， 在main作用域中没有b

	if (1)
	{
		//在复合语句中定义，只在复合语句中有效
		int a = 10;
		printf("a = %d\n", a);
	}

	//a = 10; //err离开if()的复合语句，a已经不存在
	
	return 0;
}
```

## 静态(static)局部变量

-   ==static局部变量的作用域也是在定义的函数内有效==

-   static局部变量的生命周期和程序运行周期一样，同时==staitc局部变量的值只初始化一次，但可以赋值多次==

-   ==static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符==

```c
#include <stdio.h>

void fun1()
{
	int i = 0;
	i++;
	printf("i = %d\n", i);
}

void fun2()
{
	//静态局部变量，没有赋值，系统赋值为0，而且只会初始化一次
	static int a;
	a++;
	printf("a = %d\n", a);
}

int main(void)
{
	fun1();
	fun1();
	fun2();
	fun2();
	
	return 0;
}
```

## 全局变量

-   在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量,须用extern声明

-   全局变量的生命周期和程序运行周期一样

-   不同文件的全局变量不可重名

## 静态(static)全局变量

-   在函数外定义,作用范围被限制在所定义的文件中

-   ==不同文件静态全局变量可以重名,但作用域不冲突==

-   ==static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次==

## extern全局变量声明

==extern int a;==

==声明一个变量，这个全局变量在别的文件中已经定义了，这里只是声明，而不是定义。==

## 全局函数和静态函数

==在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。==

对于不同文件中的staitc函数名字可以相同:

![全局函数和静态函数](https://raw.githubusercontent.com/YangLuchao/c_study/main/%E5%9B%BE/%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0.png)

==注意：==

-   允许在不同的函数中使用相同的变量名，它们代表不同的对象，分配不同的单元，互不干扰。

-   同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。

-   ==所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。==

## 总结

| ***\*类型\**** | ***\*作用域\**** | ***\*生命周期\**** |      |
| -------------- | ---------------- | ------------------ | ---- |
| auto变量       | 一对{}内         | 当前函数           |      |
| static局部变量 | 一对{}内         | 整个程序运行期     |      |
| extern变量     | 整个程序         | 整个程序运行期     |      |
| static全局变量 | 当前文件         | 整个程序运行期     |      |
| extern函数     | 整个程序         | 整个程序运行期     |      |
| static函数     | 当前文件         | 整个程序运行期     |      |
| register变量   | 一对{}内         | 当前函数           |      |
| 全局变量       | 整个程序         | 整个程序运行期     |      |

# 内存布局

## 内存分区

C代码经过==预处理、编译、汇编、链接==4步后生成一个可执行程序。

在 Windows 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：

![二进制可执行文件基本情况](https://raw.githubusercontent.com/YangLuchao/c_study/main/%E5%9B%BE/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5.png)

通过上图可以得知，在没有运行程序前，也就是说==程序没有加载到内存前==，可执行程序内部已经分好3段信息，分别为==代码区（text）、数据区（data）和未初始化数据区（bss）==3 个部分（有些人==直接把data和bss合起来叫做静态区或全局区==）。

### 代码区

存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。==代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令==。另外，代码区还规划了局部变量的相关信息。

### 全局初始化数据区/静态数据区（data段）

该区包含了在程序中==明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）==

### 未初始化数据区（又叫 bss 区）

存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。

==程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变==。然后，==运行可执行程序，系统把程序加载到内存==，==除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外==，==还额外增加了栈区、堆区==。













