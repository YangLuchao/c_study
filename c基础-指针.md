[toc]

# 概述

## 物理储存器和储存地址空间

物理存储器：实际存在的具体存储器芯片。

-   主板上装插的内存条

-   显示卡上的显示RAM芯片

-   各种适配卡上的RAM芯片和ROM芯片

存储地址空间：对存储器编码的范围。我们在软件上常说的内存是指这一层含义

-   ==编码：对每个物理存储单元（一个字节）分配一个号码==

-   ==寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写==

## 内存地址

-   ==将内存抽象成一个很大的一维字符数组。==

-   ==编码就是对内存的每一个字节分配一个32位或64位的编号（与32位或者64位处理器相关）。==

-   ==这个内存编号我们称之为内存地址。==

-   内存中的每一个数据都会分配相应的地址：

    -   ==char:占一个字节分配一个地址==

    -   ==int: 占四个字节分配四个地址==

    -   float、struct、函数、数组等

## 指针和指针变量

-   ==内存区的每一个字节都有一个编号，这就是“地址”。==

-   ==如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)==

-   ==指针的实质就是内存“地址”。指针就是地址，地址就是指针。==

-   ==指针是内存单元的编号，指针变量是存放地址的变量。==

-   ==通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。==

# 指针基础

-   ==指针也是一种数据类型，指针变量也是一种变量==

-   ==指针变量指向谁，就把谁的地址赋值给指针变量==

-   ==“*”操作符操作的是指针变量指向的内存空间==

```c
#include <stdio.h>

int main()
{
	int a = 0;
	char b = 100;
	printf("%p, %p\n", &a, &b); //打印a, b的地址

	//int *代表是一种数据类型，int*指针类型，p才是变量名
	//定义了一个指针类型的变量，可以指向一个int类型变量的地址
	int *p;
	p = &a;//将a的地址赋值给变量p，p也是一个变量，值是一个内存地址编号
	printf("%d\n", *p);//p指向了a的地址，*p就是a的值

	char *p1 = &b;
	printf("%c\n", *p1);//*p1指向了b的地址，*p1就是b的值

	return 0;
}
```

==注意：&可以取得一个变量在内存中的地址。但是，不能取寄存器变量，因为寄存器变量不在内存里，而在CPU里面，所以是没有地址的。==

## 通过指针简介修改变量的值

```c
	int a = 0;
	int b = 11;
	int *p = &a;

	// 将*p指针指向的地址的值赋值为100
	*p = 100;
	printf("a = %d, *p = %d\n", a, *p);
	// a = 100, *p = 100

	// 将b的地址赋值给变量p，p也是一个变量，值是一个内存地址编号
	p = &b;
	*p = 22;
	printf("b = %d, *p = %d\n", b, *p);
```

==p就是b的地址==

==*p就是b的值==

### 指针大小

-   使用sizeof()测量指针的大小，得到的总是：4或8

-   sizeof()测的是指针变量指向存储地址的大小

-   ==在32位平台，所有的指针（地址）都是32位(4字节)==

-   ==在64位平台，所有的指针（地址）都是64位(8字节)==

### 野指针和空指针

指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，==任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针==，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，==野指针不会直接引发错误，操作野指针指向的内存区域才会出问题==。

```c
	int a = 100;
	int *p;
	p = a; //把a的值赋值给指针变量p，p为野指针， ok，不会有问题，但没有意义

	p = 0x12345678; //给指针变量p赋值，p为野指针， ok，不会有问题，但没有意义

	*p = 1000;  //操作野指针指向未知区域，内存出问题，err
```

但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。

NULL是一个值为0的宏常量：

```c
#define NULL    ((void *)0)
```

### 万能指针void *

void *指针可以指向任意变量的内存空间：

```c
	void *p = NULL;

	int a = 10;
	p = (void *)&a; //指向变量时，最好转换为void *

	// 使用指针变量指向的内存时，转换为int *
	*( (int *)p ) = 11;
	printf("a = %d\n", a);
```

### const修饰的指针变量

重点关注两个概念，==指针指向的内存区域、指针的指向==

==const int *p1：指向常量的指针，指针指向的内存区域不能变，指正指向可以变==

==int * const p2：指针常量，指针指向不能变，指针指向的内存可以变==

```c
	int a = 100;
	int b = 200;

	// 指向常量的指针
	// 修饰*，指针指向内存区域不能修改，指针指向可以变
	const int *p1 = &a; //等价于int const *p1 = &a;
	//*p1 = 111; //err
	p1 = &b; //ok

	// 指针常量
	// 修饰p1，指针指向不能变，指针指向的内存可以修改
	int * const p2 = &a;
	//p2 = &b; //err
	*p2 = 222; //ok
```

# 指针和数组

## 数组名字

是数组的首元素地址，但它是一个地址常量

```c
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; 
	printf("a = %p\n", a);
	printf("&a[0] = %p\n", &a[0]);

	//a = 10; //err, 数组名只是常量，不能修改
```

## 指针操作数组元素

```c
#include <stdio.h>

int  main()
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int i = 0;
  // 计算a数组的长度
  // sizeof(a)，计算a数组的大小
  // sizeof(a[0]),计算a第0个元素的大小
	int n = sizeof(a) / sizeof(a[0]);
	
	for (i = 0; i < n; i++)
	{
    // a[i]是取a数组的第i个元素，和java/js的语法一样
		printf("%d, ", a[i]);
    // a+i是取a数组的第i个元素的内存地址，*(a+i)是取那个内存地址上的值
		printf("%d, ", *(a+i));
	}
	printf("\n");

  // 定义一个指针变量保存a的地址
  // p是a数组首元素的内存地址
  // *p是a数组该内存地址上的元素值
	int *p = a; 	
	for (i = 0; i < n; i++)
	{
    // p[i]是a数组第i个元素的值
    // 等价与a[i]
		p[i] = 2 * i;
	}

	for (i = 0; i < n; i++)
	{
    // p+i是取a数组第i个元素的内存地址，等价于a+i
    // *(p+i)是取那个内存地址上的值，等价与*(a+i)
		printf("%d, ", *(p + i));
	}
	printf("\n");

	return 0;
}
```

## 指针的加减运算

### 加法运算

-   ==指针计算不是简单的整数相加==

-   ==如果是一个int *，+1的结果是增加一个int的大小==

-   ==如果是一个char *，+1的结果是增加一个char大小==

```c
#include <stdio.h>

int main()
{
  // 定义一个a 
	int a;
  // &a是a的内存地址，就是a的引用
	int *p = &a;
  // p是a的地址
	printf("%d\n", p);
  // p=p+2,p移动了2个int
	p += 2;
  // int是4个字节，两个int就是8个字节
  // 假如p=100
  // p+=2后p=108
	printf("%d\n", p);

	char b = 0;
	char *p1 = &b;
	printf("%d\n", p1);
	p1 += 2;//移动了2个char
  // char是1字节
  // 假如p1=100
  // p1+=2后p1=102
	printf("%d\n", p1);

	return 0;
}
```

通过改变指针指向操作数组元素:

```c
#include <stdio.h>

int main()
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int i = 0;
	int n = sizeof(a) / sizeof(a[0]);

	int *p = a;
	for (i = 0; i < n; i++)
	{
		printf("%d, ", *p);
    // p是地址，而且*p是int类型，所以p++，在内存上每次移动一个int型大小的位置
		p++;
	}
	printf("\n");
	
	return 0;
}
```

### 减法运算

```c
#include <stdio.h>

int main()
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int i = 0;
	int n = sizeof(a) / sizeof(a[0]);

	int *p = a+n-1;
	for (i = 0; i < n; i++)
	{
		printf("%d, ", *p);
    // 内存地址上减一个int型的值
		p--;
	}
	printf("\n");

	return 0;
}
```

```c
#include <stdio.h>

int main()
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int *p2 = &a[2]; //第2个元素地址
	int *p1 = &a[1]; //第1个元素地址
	printf("p1 = %p, p2 = %p\n", p1, p2);

  // p2和p1只差个内存位置
  // 所以p2减p1等于1
	int n1 = p2 - p1; //n1 = 1
  // 强转为int后，一个int类型4个字节
	int n2 = (int)p2 - (int)p1; //n2 = 4
	printf("n1 = %d, n2 = %d\n", n1, n2);
	
	return 0;
}
```

## 指针数组

指针数组，它是数组，数组的每个元素都是指针类型。

```c
#include <stdio.h>

int main()
{
	//指针数组
	int *p[3];
	int a = 1;
	int b = 2;
	int c = 3;
	int i = 0;

	p[0] = &a;
	p[1] = &b;
	p[2] = &c;

	for (i = 0; i < sizeof(p) / sizeof(p[0]); i++ )
	{
		printf("%d, ", *(p[i]));
	}
	printf("\n");
	
	return 0;
}
```

# 多级指针

-   C语言允许有多级指针存在，在实际的程序中一级指针最常用，其次是二级指针。

-   二级指针就是指向一个一级指针变量地址的指针。

-   三级指针基本用不着，但考试会考。

```c
	int a = 10;
	int *p = &a; //一级指针
	*p = 100; //*p就是a

	int **q = &p;
	//*q就是p
	//**q就是a

	int ***t = &q;
	//*t就是q
	//**t就是p
	//***t就是a
```

# 指针和函数

## 函数形参改变实参的值

```c
#include <stdio.h>

/**
值传递，只改变形参的值，不会改变实参的值
*/
void swap1(int x, int y)
{
	int tmp;
	tmp = x;
	x = y;
	y = tmp;
	printf("x = %d, y = %d\n", x, y);
}
/**
引用传递，改变形参的值的同时，改变实参的值
*/
void swap2(int *x, int *y)
{
	int tmp;
	tmp = *x;
	*x = *y;
	*y = tmp;
}

/**
值传递与引用传递最直接的解释
java中只有值传递
值传递和引用传递最直接的区别就是对传递对象是否复制
java中基本类型就直接是值传递，形参不会影响实参
引用类型，其实是将对象的引用(地址/句柄)复制作为实参传给形参，形参操作的是对象的引用的副本
*/
int main()
{
	int a = 3;
	int b = 5;
	swap1(a, b); //值传递
	printf("a = %d, b = %d\n", a, b);

	a = 3;
	b = 5;
	swap2(&a, &b); //地址传递
	printf("a2 = %d, b2 = %d\n", a, b);

	return 0;
}
```

## 数组名做函数的实参

==数组名做函数参数，函数的形参会退化为指针：==

```c
#include <stdio.h>

void printArrary(int *a, int n)	
{
	int i = 0;
	for (i = 0; i < n; i++)
	{
		printf("%d, ", a[i]);
	}
	printf("\n");
}

int main()
{
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	int n = sizeof(a) / sizeof(a[0]);

	//数组名做函数参数
	printArrary(a, n); 
	return 0;
}
```

## 指针做为函数的返回值

```c
#include <stdio.h>

int a = 10;

int *getA()
{
	return &a;
}


int main()
{
	*( getA() ) = 111;
	printf("a = %d\n", a);

	return 0;
}
```

# 指针和字符串

## 字符的指针

```c
#include <stdio.h>

int main()
{
	char str[] = "hello world";
	char *p = str;
	*p = 'm';
	p++;
	*p = 'i';
	printf("%s\n", str);

	p = "mike jiang";
	printf("%s\n", p);

	char *q = "test";
	printf("%s\n", q);

	return 0;
}
```

